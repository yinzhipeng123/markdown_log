



```bash
[root@k8smaster1 ~]# ll /opt/cni/bin/
total 98068
-rwxr-xr-x 1 work games  4500413 Mar 18  2025 bandwidth        # 控制 Pod 网络带宽限制（入站/出站速率控制）
-rwxr-xr-x 1 work games  5026019 Mar 18  2025 bridge           # 创建 Linux bridge，并将容器网络接口连接到该网桥
-rwxr-xr-x 1 work games 12204307 Mar 18  2025 dhcp             # 通过 DHCP 协议为容器分配 IP 地址
-rwxr-xr-x 1 work games  4716480 Mar 18  2025 dummy            # 创建虚拟 dummy 接口，用于测试或虚拟网络拓扑
-rwxr-xr-x 1 work games  5308174 Mar 18  2025 firewall         # 基于 iptables 设置容器网络防火墙规则
-rwxr-xr-x 1 work games  4649989 Mar 18  2025 host-device      # 让容器直接使用宿主机上的某个物理或虚拟网卡
-rwxr-xr-x 1 work games  3965030 Mar 18  2025 host-local       # 由宿主机本地 IPAM（IP 地址管理）为容器分配静态 IP
-rwxr-xr-x 1 work games  4733958 Mar 18  2025 ipvlan           # 使用 IPvlan 机制实现轻量级的网络隔离（比 macvlan 更省资源）
-rwxr-xr-x 1 work games  4038329 Mar 18  2025 loopback         # 配置容器内的回环接口（127.0.0.1），必备基础插件
-rwxr-xr-x 1 work games  4763452 Mar 18  2025 macvlan          # 使用 macvlan 驱动为容器创建独立 MAC 地址的接口
-rwxr-xr-x 1 work games  4538969 Mar 18  2025 portmap          # 设置容器端口与宿主机端口之间的映射（NAT）
-rwxr-xr-x 1 work games  4890204 Mar 18  2025 ptp              # 创建点对点网络接口（Point-to-Point，用于两个网络命名空间直连）
-rwxr-xr-x 1 work games  4246778 Mar 18  2025 sbr              # “Source Based Routing” 插件，用于源路由配置支持
-rwxr-xr-x 1 work games  3514145 Mar 18  2025 static           # 基于静态配置文件为容器分配固定 IP
-rwxr-xr-x 1 work games  4128674 Mar 18  2025 tuning           # 用于调整网络接口参数（如 MTU、队列长度、Tx/Rx 等）
-rwxr-xr-x 1 work games  4728353 Mar 18  2025 vlan             # 使用 VLAN 标签实现容器之间的二层隔离
-rwxr-xr-x 1 work games  4263979 Mar 18  2025 vrf              # 将容器接口绑定到特定的 VRF（虚拟路由转发）实例，实现多路由表隔离

```



📁 `/opt/cni/bin/` 是 **CNI 插件二进制文件的存放路径**。

当 Kubernetes（或任何容器运行时，比如 containerd、CRI-O、Docker）启动一个 Pod 时，它会调用这些 CNI 插件来**配置容器的网络**（例如创建网桥、分配 IP、设置路由等）。



### 这些插件是怎么用的？

这些不是你手动运行的命令，而是 Kubernetes 在创建 Pod 时自动调用的。
 调用逻辑大概是这样的：

1. kubelet 启动 Pod → 调用 containerd 创建容器。
2. containerd 调用 CNI → 到 `/opt/cni/bin/` 找到对应插件。
3. 执行插件命令，并读取 `/etc/cni/net.d/*.conf` 配置文件。
4. 插件负责创建网桥、分配 IP、设置路由等。

------

### 常见的配合文件路径

| 目录              | 作用                                           |
| ----------------- | ---------------------------------------------- |
| `/opt/cni/bin/`   | 存放插件二进制文件。                           |
| `/etc/cni/net.d/` | 存放网络配置文件（定义使用哪些插件、网段等）。 |
| `/var/lib/cni/`   | 存放 CNI 运行时状态（分配的 IP、网卡信息）。   |

------

### 

✅ `/opt/cni/bin/` 是 CNI 插件目录
 ✅ 这些文件是用来给容器配置网络的执行程序
 ✅ 不是你直接运行的命令，而是由 Kubernetes 自动调用
 ✅ 自定义的 `cloudbed-*`、`pcb-*` 是你所在环境的专用扩展



CNI（Container Network Interface）是 **CNCF（Cloud Native Computing Foundation）** 制定的开放规范，用于定义**容器网络插件的接口标准**。
 早期由 **CoreOS**（后来并入 Red Hat）发起，后来成为 Kubernetes 默认网络机制之一。

在它的官方规范中（见 [CNI GitHub 官方文档](https://github.com/containernetworking/cni)），定义了两个关键目录：

| 目录               | 官方说明                                                     | 常见路径          |
| ------------------ | ------------------------------------------------------------ | ----------------- |
| **插件二进制路径** | 所有 CNI 可执行文件（bridge、host-local、macvlan 等）必须放在这个目录下，供容器运行时调用。 | `/opt/cni/bin/`   |
| **网络配置路径**   | 存放 `.conf` 或 `.conflist` 文件，描述 Pod 网络要使用哪些插件、子网、路由等。 | `/etc/cni/net.d/` |

这两个路径虽然不是“强制”的，但几乎所有主流实现都遵循它：

- Kubernetes（kubelet + containerd + CRI-O）
- Docker 的 CNI 模式
- Calico / Flannel / Weave / Multus 等插件

所以它成为了事实标准（de facto standard）。