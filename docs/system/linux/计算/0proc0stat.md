# /proc/stat



Linux 作为一个多任务操作系统，将每个 CPU 的时间划分为很短的时间片，再通过调度器轮流分配给各个任务使用，因此造成多任务同时运行的错觉。为了维护 CPU 时间，Linux 通过事先定义的节拍率（内核中表示为 HZ），触发时间中断，并使用全局变量 Jiffies 记录了开机以来的节拍数。每发生一次时间中断，Jiffies 的值就加 1。节拍率 HZ 是内核的可配选项，可以设置为 100、250、1000 等。不同的系统可能设置不同数值，你可以通过查询 /boot/config 内核选项来查看它的配置值。比如在我的系统中，节拍率设置成了 250，也就是每秒钟触发 250 次时间中断。

```bash
$ grep 'CONFIG_HZ=' /boot/config-$(uname -r)
CONFIG_HZ=250
```

同时，正因为节拍率 HZ 是内核选项，所以用户空间程序并不能直接访问。为了方便用户空间程序，内核还提供了一个用户空间节拍率 USER_HZ，它总是固定为 100，也就是 1/100 秒。这样，用户空间程序并不需要关心内核中 HZ 被设置成了多少，因为它看到的总是固定值 USER_HZ。可以通过shell命令getconf获得USER_HZ的值：

```bash
$ getconf CLK_TCK
100
```

Linux 通过 /proc 虚拟文件系统，向用户空间提供了系统内部状态的信息，而 /proc/stat 提供的就是系统的 CPU 和任务统计信息

```bash
cat /proc/stat  #字段分析
name   user   nice   system      idle      iowait  irq  softirq  steal guest guest_nice
cpu   1555642  669  2099918  2037922253   108177    0    846       0     0     0
cpu0  390236   152  518894   509488581    59734     0    400       0     0     0
cpu1  389565   185  518440   509575105    9633      0    90        0     0     0
intr 7992681663 88 10 0 0 387 0 3 0 0 0 0 0 15 0 5006480 0 0 0 0 0 0 0 0 0 0 2800156 10 4339158 1 1130485 1 0 343 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
ctxt 15495936005
btime 1647854161
processes 350890
procs_running 1
procs_blocked 0
softirq 390587275 1 183430424 0 16033987 5297647 0 16 140024376 0 45800824
```

这里的输出结果是一个表格。其中，第一列表示的是 CPU 编号，如 cpu0、cpu1 ，而第一行没有编号的 cpu ，表示的是所有 CPU 的累加。其他列则表示不同场景下 CPU 的累加节拍数，它的单位是 USER_HZ，也就是 10 ms（1/100 秒），所以这其实就是不同场景下的 CPU 时间。

![img](https://raw.githubusercontent.com/yinzhipeng123/Picture_Bed/main/202205200143705.png)

计算cpu0的使用率，就把（cpu0一行中所有数字加在一起 减去 idle ）除以 cpu0一行中所有数字加在一起



- user（通常缩写为 us），代表用户态 CPU 时间。
- nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。

- system（通常缩写为 sys），代表内核态 CPU 时间。

- idle（通常缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。

- iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。

- irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。

- softirq（通常缩写为 si），代表处理软中断的 CPU 时间。

- steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。

- guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。

- guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。



- intr 记录系统中的中断数，第一列为系统中所有的中断数。后面列数都是特定的每种中断数的次数
- ctxt 系统的上下文切换次数
- btime 系统启动了多少时间
- processes  自从系统启动后fork了多少次
- procs_running 处于可运行状态的线程数
- procs_blocked 阻塞等待 I/O 的线程数 
-  softirq  此行显示所有 CPU 的软中断数。第一列是所有软中断的总数和，后面列数都是特定的每种中断数的次数

https://man7.org/linux/man-pages/man5/proc.5.html