# ifconfig详解

https://wangchujiang.com/linux-command/c/ifconfig.html

```bash
[root@VM-0-16-centos ~]# ifconfig
docker0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
        inet6 fe80::42:7ff:fea7:3e8b  prefixlen 64  scopeid 0x20<link>
        ether 02:42:07:a7:3e:8b  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 5  bytes 526 (526.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0 
```



`ifconfig` 命令输出的每个字段代表了网络接口的详细信息。下面是 提供的 `docker0` 接口输出的逐项解释：

```
docker0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST> mtu 1500
```
- `docker0`：接口名称，表示 Docker 虚拟网络接口。
- `flags=4163`：网络接口的标志位。 `4163` 是一个十进制值，表示接口的状态标志。`<UP,BROADCAST,RUNNING,MULTICAST>` 是对应的标志位的名称，具体含义如下：
  - `UP`：接口已启用。
  - `BROADCAST`：接口支持广播。
  - `RUNNING`：接口已运行，物理连接正常。
  - `MULTICAST`：接口支持多播。
- `mtu 1500`：最大传输单元（MTU），表示网络接口每次传输数据包的最大大小，这里是 1500 字节。

```
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
```
- `inet 172.17.0.1`：IPv4 地址，表示接口的 IP 地址是 `172.17.0.1`。
- `netmask 255.255.0.0`：子网掩码，表示网络的大小，这里是 `255.255.0.0`，表示该网络有 65536 个可用地址。
- `broadcast 172.17.255.255`：广播地址，表示该子网的广播地址是 `172.17.255.255`。

```
        inet6 fe80::42:7ff:fea7:3e8b  prefixlen 64  scopeid 0x20<link>
```
- `inet6 fe80::42:7ff:fea7:3e8b`：IPv6 地址，表示该接口的 IPv6 地址是 `fe80::42:7ff:fea7:3e8b`。
- `prefixlen 64`：IPv6 地址的前缀长度，表示网络部分的位数为 64 位。
- `scopeid 0x20<link>`：IPv6 地址的作用域标识符，这里是链路本地地址（`link`），通常用于局域网通信。

```
        ether 02:42:07:a7:3e:8b  txqueuelen 0  (Ethernet)
```
- `ether 02:42:07:a7:3e:8b`：以太网 MAC 地址，表示该接口的物理地址是 `02:42:07:a7:3e:8b`。
- `txqueuelen 0`：传输队列的长度。`0` 表示没有队列。通常用于控制网络包的缓冲区大小。
- `(Ethernet)`：接口类型，表明这是一个以太网接口。

```
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
```
- `RX packets 0`：接收的数据包数，这里是 `0`，表示没有接收到数据包。
- `bytes 0 (0.0 B)`：接收的字节数，这里是 `0` 字节。
- `RX errors 0`：接收错误的次数，这里是 `0`。
- `dropped 0`：丢失的数据包数，这里是 `0`。
- `overruns 0`：接收溢出的次数，表示接收队列满时发生的丢包，这里是 `0`。
- `frame 0`：接收的帧错误数，这里是 `0`。

```
        TX packets 5  bytes 526 (526.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```
- `TX packets 5`：发送的数据包数，这里是 `5`，表示发送了 5 个数据包。
- `bytes 526 (526.0 B)`：发送的字节数，这里是 `526` 字节。
- `TX errors 0`：发送错误的次数，这里是 `0`。
- `dropped 0`：发送丢失的数据包数，这里是 `0`。
- `overruns 0`：发送溢出的次数，这里是 `0`。
- `carrier 0`：载波检测错误的次数，表示物理链路的状态，这里是 `0`。
- `collisions 0`：数据包碰撞次数，表示在传输过程中发生的冲突，这里是 `0`。



## `overruns` 

`overruns` 是网络接口统计中的一个字段，表示接收或发送数据时发生的**溢出**。它描述的是在网络接口的接收队列或发送队列满时，新的数据包被丢弃的次数。

具体来说，`overruns` 包含以下两种情况：

### 1. **接收溢出（RX overruns）**
当网卡接收到数据包时，如果网络接口的接收队列已经满了，而操作系统没有及时处理这些数据包，那么新的数据包将会被丢弃。这个丢弃现象就称为“接收溢出”或“接收队列溢出”。
- 这种情况通常发生在网卡接收速度过快，而主机处理能力不足时。
- 在高流量的网络环境下，特别是当网络接口无法及时处理所有传入的数据包时，会看到接收溢出的情况。

### 2. **发送溢出（TX overruns）**
发送溢出发生在数据包被送入发送队列时，如果网络接口的发送队列已经满了，新的数据包就会被丢弃。这通常意味着数据包无法被及时传送到网络中去。
- 发送溢出一般发生在主机发送速度过快，或者网络接口未能及时处理发送的流量时。

### 溢出的原因
- **CPU 资源不足**：处理数据包的 CPU 可能不足以应对高速的数据传输，导致网络接口无法及时读取或写入数据包。
- **网络拥塞**：网络中大量的数据流可能导致接口的缓冲区快速满载，进而发生溢出。
- **驱动或硬件问题**：某些网络驱动或硬件可能存在性能瓶颈，导致队列溢出。

### 如何查看和解决
1. **查看溢出数量**：可以通过 `ifconfig` 或 `netstat -i` 命令查看接收和发送溢出次数。如果这些值较高，说明存在性能问题。
2. **调整缓冲区大小**：可以通过调整操作系统或网络接口的接收和发送缓冲区大小来减少溢出的发生。在 Linux 中，可以使用 `ethtool` 命令来调整网卡的缓冲区大小。
3. **升级硬件或驱动**：如果溢出频繁发生，可能需要考虑更强的网络硬件，或更新网络驱动程序，以提升网络接口的处理能力。
4. **优化流量管理**：减少不必要的网络流量，或使用流量控制技术（如 QoS）来优化数据流的传输。





## 要查看网卡的接收队列（RX队列）和发送队列（TX队列）使用情况



### 1. **使用 `ifconfig` 命令**
`ifconfig` 命令可以显示网卡的基本信息，但它并不直接显示队列的使用情况。然而，可以查看每个网卡接口的基本流量统计信息，如接收和发送的数据包数（`RX packets` 和 `TX packets`）。但要查看详细的队列信息，`ifconfig` 并不提供。

### 2. **使用 `ethtool` 命令**
`ethtool` 是一个非常强大的工具，它可以用来查看和调整网卡的参数，包括队列的状态。

要查看网卡的队列信息， 可以使用以下命令：

```bash
ethtool -S <网卡接口名>
```

例如，要查看 `eth0` 网卡的详细统计信息，可以执行：

```bash
ethtool -S eth0
```

这将显示网卡的多个统计指标，包括接收和发送队列的使用情况。输出中可能包含以下字段：
- `rx_dropped`：接收队列丢包的数量。
- `tx_dropped`：发送队列丢包的数量。
- `rx_bytes`：接收的字节数。
- `tx_bytes`：发送的字节数。

此外，`ethtool` 还可以查看网卡队列的长度，例如：

```bash
ethtool -g eth0
```

这会显示网卡的接收和发送队列的大小（`RX` 和 `TX` 队列的大小）。

### 3. **查看 `/sys/class/net/<网卡接口>/statistics` 目录**
在 Linux 系统中，每个网络接口都有一个 `/sys/class/net/<网卡接口>/statistics/` 目录， 可以通过查看这个目录中的文件来获取网卡的详细统计数据。

例如，要查看 `eth0` 接口的接收和发送队列统计信息， 可以执行以下命令：

```bash
cat /sys/class/net/eth0/statistics/rx_dropped
cat /sys/class/net/eth0/statistics/tx_dropped
cat /sys/class/net/eth0/statistics/rx_bytes
cat /sys/class/net/eth0/statistics/tx_bytes
```

这些文件会返回接收丢包（`rx_dropped`）、发送丢包（`tx_dropped`）、接收字节数（`rx_bytes`）和发送字节数（`tx_bytes`）等数据。

### 4. **使用 `netstat` 命令**
`netstat` 命令可以显示网络连接、路由表、接口状态等信息，但并不直接显示队列的使用情况。 可以使用 `netstat -i` 来查看接口的统计数据：

```bash
netstat -i
```

这个命令显示了各个接口的统计信息，如接收和发送的数据包数，但它没有直接显示队列的详细使用情况。

### 5. **查看系统日志**
如果网卡发生溢出或其他性能问题，通常会在系统日志中记录相关信息。可以使用 `dmesg` 或 `journalctl` 命令来查看内核日志。

例如：

```bash
dmesg | grep eth0
```

或

```bash
journalctl -k | grep eth0
```

这些命令可以帮助 检查系统日志，查看是否有与队列溢出、错误等相关的警告或错误信息。

### 总结
- **`ethtool -S`** 和 **`ethtool -g`** 是查看队列使用情况和队列大小的最佳工具。
- **`/sys/class/net/<网卡接口>/statistics/`** 目录也能提供详细的接收和发送队列的统计数据。
- **`ifconfig`** 和 **`netstat`** 提供的统计信息更为简洁，但不包含队列的详细使用情况。



## ethtool查看支持队列数

```
[root@VM-0-16-centos ~]# ethtool -g eth0
Ring parameters for eth0:
Pre-set maximums:
RX:             1024
RX Mini:        n/a
RX Jumbo:       n/a
TX:             1024
Current hardware settings:
RX:             1024
RX Mini:        n/a
RX Jumbo:       n/a
TX:             1024   
```

根据  提供的 `ethtool -g eth0` 输出，网卡 `eth0` 支持的队列信息如下：

### 输出解读：
- **Pre-set maximums**：
  - **RX**: 1024 — 表示接收队列（RX）最多可以设置 1024 个。
  - **TX**: 1024 — 表示发送队列（TX）最多可以设置 1024 个。
  - **RX Mini**: n/a — 表示网卡没有特别的“小型接收队列”（Mini 队列）。
  - **RX Jumbo**: n/a — 表示网卡没有特别的“超大接收队列”（Jumbo 队列）。

- **Current hardware settings**：
  - **RX**: 1024 — 当前网卡的接收队列设置为 1024 个。
  - **TX**: 1024 — 当前网卡的发送队列设置为 1024 个。

### 队列的含义：
1. **RX (接收队列)**：网卡接收到的数据包会被存放到接收队列中，操作系统会从这些队列中取出数据进行处理。`RX` 队列数量是指网卡在硬件层面支持的最大接收队列数。  当前的设置是 1024 个接收队列。
   
2. **TX (发送队列)**：发送队列类似，网络数据包从操作系统到网卡的发送路径也是通过发送队列传递的。`TX` 队列数量表示网卡支持的最大发送队列数。  当前的设置是 1024 个发送队列。

3. **RX Mini 和 RX Jumbo**：这是与“mini frame”和“jumbo frame”相关的特殊队列。Mini frames 是较小的数据包，通常用于网络优化，而 Jumbo frames 是比标准以太网帧（通常是 1500 字节）更大的数据包（如 9000 字节），常用于大数据量的传输。根据  的输出，  的网卡不支持这两种特殊队列（显示为 `n/a`）。

### 队列数量的影响：
- **队列数目**越多，网卡的处理能力越强，尤其是在多核 CPU 系统中，多队列可以实现更好的负载均衡，每个队列可以由不同的 CPU 核心进行并行处理，提升网络吞吐能力。
- 这里的队列数表示**最大支持的队列数量**，并不代表当前正在使用的队列数。具体使用多少个队列，通常取决于操作系统的配置和负载分配策略。大多数网卡和操作系统默认只使用一部分队列。

### 查看当前使用的队列数：
虽然  当前的设置是支持 1024 个接收和发送队列，但实际使用的队列数量取决于系统的网络配置和流量负载。  可以使用 `ethtool -S eth0` 来查看实际使用的接收队列和发送队列的统计信息，比如每个队列处理的数据包数量。





## 增加队列

如果希望增加网卡的队列数，可以通过调整网卡的参数来实现。下面是手动增加网卡队列数的步骤，但请注意，这个操作通常依赖于网卡和操作系统的支持。

### 1. **查看当前队列数**  
 可以通过 `ethtool` 命令来查看当前网卡的队列数：

```bash
ethtool -g eth0
```

这个命令会显示出网卡当前的队列数，包括接收队列（RX）和发送队列（TX）。

### 2. **增加队列数**  
 可以使用 `ethtool` 命令来修改网卡的队列数。例如，假设 想将接收队列和发送队列都增加到 4 个队列，可以运行以下命令：

```bash
ethtool -L eth0 rx 4 tx 4
```

- `-L` 参数用来设置队列数量。
- `rx 4` 表示将接收队列增加到 4 个。
- `tx 4` 表示将发送队列增加到 4 个。

### 3. **确认修改是否生效**  
修改完成后， 可以使用 `ethtool -g eth0` 来确认队列数是否已经成功增加。

### 4. **自动加载队列配置**  
增加的队列数可能是临时的，即在系统重启后会恢复默认设置。如果 想让这个设置永久生效，可以将其添加到系统启动脚本中。

#### 例如：
- 在 CentOS 或 RHEL 系统中， 可以将命令添加到 `/etc/rc.d/rc.local` 文件中：
  
  ```bash
  echo "ethtool -L eth0 rx 4 tx 4" >> /etc/rc.d/rc.local
  ```

- 确保 `/etc/rc.d/rc.local` 文件是可执行的：

  ```bash
  chmod +x /etc/rc.d/rc.local
  ```

这样，每次系统重启时，队列数会自动设置为 指定的数量。

### 5. **检查硬件支持**  
虽然现代网卡通常支持多队列功能，但并非所有网卡都支持极高数量的队列，增加队列的数量取决于硬件的能力。如果 的网卡或驱动不支持某个数量的队列，`ethtool` 会返回错误信息，表示设置无效。

### 6. **性能测试**  
增加队列数后，建议进行一定的性能测试，查看系统的网络吞吐量是否有所提升。 可以使用如 `iperf` 等工具来进行网络性能测试。

### 7. **使用 CPU 核心**  
如果 的系统有多个 CPU 核心，并且网卡支持多队列，确保操作系统已启用**多队列网络调度**，以便每个队列能够独立地由不同的 CPU 核心处理。 可以查看 `/sys/class/net/eth0/queues/` 路径下的队列配置文件，确保队列分配得当。

```bash
ls /sys/class/net/eth0/queues/
```

### 总结：
- 使用 `ethtool -L eth0 rx <队列数> tx <队列数>` 来调整队列数量。
- 配置文件中的修改可能是临时的，需要手动添加到启动脚本来永久生效。
- 确保 的网卡支持增加队列，并在系统中合理配置多队列处理。