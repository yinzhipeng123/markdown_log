<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"> <channel><title>MarkDown_Log</title><description>yinzhipengのmarkdown_log</description><link>https://yinzhipeng123.github.io/markdown_log/</link><atom:link href="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml" rel="self" type="application/rss+xml" /><docs>https://github.com/yinzhipeng123/markdown_log/</docs><language>en-None</language> <pubDate>Tue, 03 Dec 2024 06:21:41 -0000</pubDate> <lastBuildDate>Tue, 03 Dec 2024 06:21:41 -0000</lastBuildDate> <ttl>1440</ttl> <generator>MkDocs RSS plugin - v1.7.0</generator> <image> <url>https://upload.wikimedia.org/wikipedia/commons/thumb/4/43/Feed-icon.svg/128px-Feed-icon.svg.png</url> <title>MarkDown_Log</title><link>https://yinzhipeng123.github.io/markdown_log/</link> </image> <item> <title>流表</title> <description>&lt;p&gt;&lt;code&gt;tc&lt;/code&gt; 是 Linux 中的流量控制（Traffic Control）工具，通常用于网络流量管理和带宽控制。它允许你配置、调整和监控 Linux 系统的网络接口的流量控制、队列管理、包调度等特性。&lt;code&gt;tc&lt;/code&gt; 命令的常见用途包括流量限速、流量整形、带宽分配、流量优先级等。&lt;/p&gt;&lt;h3&gt;&lt;code&gt;tc&lt;/code&gt; 命令的基本结构&lt;/h3&gt;&lt;p&gt;``...&lt;/p&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/system/linux/%E7%BD%91%E7%BB%9C/%E6%B5%81%E8%A1%A8/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Tue, 03 Dec 2024 06:22:03 +0000</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/system/linux/%E7%BD%91%E7%BB%9C/%E6%B5%81%E8%A1%A8/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/system/linux/%E7%BD%91%E7%BB%9C/%E6%B5%81%E8%A1%A8/</guid> </item> <item> <title>堆栈信息查看</title> <description>&lt;p&gt;线程之间是共享进程的内存的，但每个线程 &lt;strong&gt;拥有独立的栈&lt;/strong&gt;。这里的“共享内存”指的是线程共享进程的全局变量、堆内存和代码段，但每个线程的栈内存是独立的。&lt;/p&gt;&lt;h3&gt;具体解释：&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;共享进程内存&lt;/strong&gt;：&lt;/li&gt;&lt;li&gt;[ ] &lt;strong&gt;堆内存&lt;/strong&gt;：所有线程都共享进程的堆内存。堆通常用于动态分配内存，比如通过 `mal...&lt;/li&gt;&lt;/ol&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/system/linux/%E5%86%85%E5%AD%98/%E5%A0%86%E6%A0%88/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Tue, 03 Dec 2024 06:22:00 +0000</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/system/linux/%E5%86%85%E5%AD%98/%E5%A0%86%E6%A0%88/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/system/linux/%E5%86%85%E5%AD%98/%E5%A0%86%E6%A0%88/</guid> </item> <item> <title>pidstat查看线程内存状态</title> <description>&lt;h1&gt;pidstat 内存相关选项&lt;/h1&gt;&lt;p&gt;```bash[root@VM-0-16-centos ~]# pidstat -r -t | head -n 10Linux 5.14.0-202.el9.x86_64 (VM-0-16-centos) 12/02/2024 &lt;em&gt;x86_64&lt;/em&gt; ...&lt;/p&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/system/linux/%E5%86%85%E5%AD%98/pidstat_r/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Tue, 03 Dec 2024 06:22:00 +0000</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/system/linux/%E5%86%85%E5%AD%98/pidstat_r/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/system/linux/%E5%86%85%E5%AD%98/pidstat_r/</guid> </item> <item> <title>mq对比</title> <description>&lt;p&gt;RabbitMQ 和 RocketMQ 是两种流行的消息队列，它们适用于不同的场景，各有优缺点。以下是它们的详细对比：&lt;/p&gt;&lt;hr&gt;&lt;h3&gt;&lt;strong&gt;1. RabbitMQ&lt;/strong&gt;&lt;/h3&gt;&lt;h4&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/h4&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;成熟和稳定&lt;/strong&gt;：&lt;/li&gt;&lt;li&gt;开发时间长，拥有广泛的社区支持和插件生态。&lt;/li&gt;&lt;li&gt;经验证的 AMQP 协议...&lt;/li&gt;&lt;/ol&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/middleware/MQ/mqvs/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Tue, 03 Dec 2024 06:21:46 +0000</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/middleware/MQ/mqvs/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/middleware/MQ/mqvs/</guid> </item> <item> <title>TLB</title> <description>&lt;p&gt;TLB（Translation Lookaside Buffer）是&lt;strong&gt;翻译后备缓冲区&lt;/strong&gt;的缩写，它是一个高速缓存，用于存储虚拟地址到物理地址的映射。在计算机的内存管理中，CPU 通过虚拟地址访问内存，而操作系统通过页面表将虚拟地址映射到物理地址。由于访问页面表可能比较慢，TLB 提供了一个缓存机制，存储最近使用...&lt;/p&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/system/linux/%E5%86%85%E5%AD%98/TLB/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Fri, 29 Nov 2024 17:32:15 +0800</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/system/linux/%E5%86%85%E5%AD%98/TLB/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/system/linux/%E5%86%85%E5%AD%98/TLB/</guid> </item> <item> <title>透明大页</title> <description>&lt;p&gt;&lt;strong&gt;Transparent Huge Pages (THP)&lt;/strong&gt; 是 Linux 内核中的一种内存管理机制，它旨在提高内存访问性能，尤其是在处理大量内存时。它通过使用更大的内存页面来减少页面表的管理开销，从而提高内存访问的效率。这里是关于 THP 的一些关键概念和工作原理：&lt;/p&gt;&lt;h3&gt;1. **内存页面的基本概念...&lt;/h3&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/system/linux/%E5%86%85%E5%AD%98/%E9%80%8F%E6%98%8E%E5%A4%A7%E9%A1%B5/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Fri, 29 Nov 2024 17:32:15 +0800</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/system/linux/%E5%86%85%E5%AD%98/%E9%80%8F%E6%98%8E%E5%A4%A7%E9%A1%B5/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/system/linux/%E5%86%85%E5%AD%98/%E9%80%8F%E6%98%8E%E5%A4%A7%E9%A1%B5/</guid> </item> <item> <title>内存大页</title> <description>&lt;p&gt;&lt;strong&gt;HugePages&lt;/strong&gt; 是一种内存管理技术，允许操作系统使用&lt;strong&gt;大页面（Huge Pages）&lt;/strong&gt;而不是传统的小页面来提高内存访问效率和减少管理开销。它通常用于内存密集型的应用程序，如数据库、虚拟化、科学计算等，能够提高系统性能，减少内存分配和页面管理的开销。&lt;/p&gt;&lt;h3&gt;1. **页面（Page）与大页面（H...&lt;/h3&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/system/linux/%E5%86%85%E5%AD%98/%E5%86%85%E5%AD%98%E5%A4%A7%E9%A1%B5/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Fri, 29 Nov 2024 17:29:52 +0800</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/system/linux/%E5%86%85%E5%AD%98/%E5%86%85%E5%AD%98%E5%A4%A7%E9%A1%B5/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/system/linux/%E5%86%85%E5%AD%98/%E5%86%85%E5%AD%98%E5%A4%A7%E9%A1%B5/</guid> </item> <item> <title>查询某个机器的CPU</title> <description>&lt;p&gt;在Prometheus上查询某台机器的CPU状态，可以使用以下查询语法：&lt;/p&gt;&lt;p&gt;&lt;code&gt;rate(node_cpu_seconds_total{instance=&#34;your_machine_ip&#34;, mode=&#34;idle&#34;}[5m])&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这个查询返回指定机器（通过&lt;code&gt;instance&lt;/code&gt;标签过滤）的CPU空闲时间...&lt;/p&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/monitor/prometheus/%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA%E6%9C%BA%E5%99%A8%E7%9A%84CPU/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Fri, 29 Nov 2024 12:41:00 +0800</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/monitor/prometheus/%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA%E6%9C%BA%E5%99%A8%E7%9A%84CPU/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/monitor/prometheus/%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA%E6%9C%BA%E5%99%A8%E7%9A%84CPU/</guid> </item> <item> <title>redis支持存储的类型</title> <description>&lt;p&gt;Redis 支持多种数据类型，超越了传统数据库中的基本键值对模型。Redis 的数据类型使其能够高效地存储和处理复杂的数据结构。下面是 Redis 支持的主要数据类型及其特点：&lt;/p&gt;&lt;h3&gt;1. &lt;strong&gt;字符串（String）&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;描述&lt;/strong&gt;：这是 Redis 中最基本的数据类型，可以存储任何形式的数据，如字符...&lt;/li&gt;&lt;/ul&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/database/redis/redis%E6%94%AF%E6%8C%81%E5%AD%98%E5%82%A8%E7%9A%84%E7%B1%BB%E5%9E%8B/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Fri, 29 Nov 2024 12:30:08 +0800</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/database/redis/redis%E6%94%AF%E6%8C%81%E5%AD%98%E5%82%A8%E7%9A%84%E7%B1%BB%E5%9E%8B/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/database/redis/redis%E6%94%AF%E6%8C%81%E5%AD%98%E5%82%A8%E7%9A%84%E7%B1%BB%E5%9E%8B/</guid> </item> <item> <title>Ansible</title> <description>&lt;p&gt;&lt;strong&gt;Ansible&lt;/strong&gt; 是一个开源的自动化工具，主要用于配置管理、应用部署、任务自动化和多节点管理。它的核心优势是简洁、易于使用且具有强大的功能。Ansible 使用 &lt;strong&gt;Playbooks&lt;/strong&gt; 来描述系统配置和自动化任务，并通过 &lt;strong&gt;SSH&lt;/strong&gt; 协议无代理地在多个服务器上执行命令。&lt;/p&gt;&lt;h3&gt;**Ansible...&lt;/h3&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/programming_language/Ansible/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Fri, 29 Nov 2024 12:30:08 +0800</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/programming_language/Ansible/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/programming_language/Ansible/</guid> </item> <item> <title>Ansible_Dome</title> <description>&lt;p&gt;要使用 Ansible 安装 &lt;code&gt;sar&lt;/code&gt;（一个用于收集和报告系统性能的工具），你可以编写一个简单的 Playbook 来实现。在这个 Playbook 中，我们将使用 Ansible 的 &lt;code&gt;package&lt;/code&gt; 模块来安装软件包。具体步骤如下：&lt;/p&gt;&lt;h3&gt;1. 创建一个 Playbook 文件&lt;/h3&gt;&lt;p&gt;首先，创建一个名为 ...&lt;/p&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/programming_language/Ansible_Dome/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Fri, 29 Nov 2024 12:30:08 +0800</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/programming_language/Ansible_Dome/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/programming_language/Ansible_Dome/</guid> </item> <item> <title>Ansible检查正确性</title> <description>&lt;p&gt;在编写 Ansible playbook 或剧本时，可以使用以下命令来检查其正确性：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ansible-playbook --syntax-check&lt;/code&gt;&lt;/strong&gt; 这是检查 Ansible playbook 语法是否正确的最常用命令。它会检查 playbook 中的 YAML 语法、模块调用和其他语...&lt;/li&gt;&lt;/ol&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/programming_language/Ansible%E6%A3%80%E6%9F%A5%E6%AD%A3%E7%A1%AE%E6%80%A7/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Fri, 29 Nov 2024 12:30:08 +0800</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/programming_language/Ansible%E6%A3%80%E6%9F%A5%E6%AD%A3%E7%A1%AE%E6%80%A7/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/programming_language/Ansible%E6%A3%80%E6%9F%A5%E6%AD%A3%E7%A1%AE%E6%80%A7/</guid> </item> <item> <title>Ansible部署</title> <description>&lt;p&gt;Ansible 是一个开源的自动化工具，可以在 Linux 和 macOS 上轻松安装。下面是不同平台上安装 Ansible 的步骤：&lt;/p&gt;&lt;h3&gt;1. &lt;strong&gt;在 Linux 上安装 Ansible&lt;/strong&gt;&lt;/h3&gt;&lt;h4&gt;通过 &lt;code&gt;apt&lt;/code&gt; 安装（适用于 Ubuntu/Debian 系统）&lt;/h4&gt;&lt;p&gt;```bashsudo apt...&lt;/p&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/programming_language/Ansible%E9%83%A8%E7%BD%B2/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Fri, 29 Nov 2024 12:30:08 +0800</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/programming_language/Ansible%E9%83%A8%E7%BD%B2/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/programming_language/Ansible%E9%83%A8%E7%BD%B2/</guid> </item> <item> <title>iptables流量标记</title> <description>&lt;p&gt;基于网络包的源 IP 地址，将流量根据来源地（香港或美国）分发到不同的网卡上。&lt;code&gt;iptables&lt;/code&gt; 负责标记流量，&lt;code&gt;ip rule&lt;/code&gt; 则根据标记选择不同的路由表，从而决定通过哪个网卡转发流量。&lt;/p&gt;&lt;h3&gt;1. 配置路由表&lt;/h3&gt;&lt;p&gt;首先，我们在 &lt;code&gt;/etc/iproute2/rt_tables&lt;/code&gt; 文件中为每个网络接口创建独...&lt;/p&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/system/centos7/iptables%E6%B5%81%E9%87%8F%E6%A0%87%E8%AE%B0/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Fri, 29 Nov 2024 12:30:08 +0800</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/system/centos7/iptables%E6%B5%81%E9%87%8F%E6%A0%87%E8%AE%B0/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/system/centos7/iptables%E6%B5%81%E9%87%8F%E6%A0%87%E8%AE%B0/</guid> </item> <item> <title>四层还是七层</title> <description>&lt;ul&gt;&lt;li&gt;使用四层负载均衡的场景：&lt;/li&gt;&lt;li&gt;[ ] 大规模 TCP/UDP 服务的负载均衡（如数据库、SMTP、DNS 服务等）。&lt;/li&gt;&lt;li&gt;[ ] 高流量、高并发的服务，主要是需要快速、无状态的负载均衡。&lt;/li&gt;&lt;li&gt;使用七层负载均衡的场景：&lt;/li&gt;&lt;li&gt;[ ] Web 应用、API 网关、微服务架构的负载均衡。&lt;/li&gt;&lt;li&gt;[ ] ...&lt;/li&gt;&lt;/ul&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/Cloud_Computing/%E5%9B%9B%E5%B1%82%E8%BF%98%E6%98%AF%E4%B8%83%E5%B1%82/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Fri, 29 Nov 2024 10:01:31 +0800</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/Cloud_Computing/%E5%9B%9B%E5%B1%82%E8%BF%98%E6%98%AF%E4%B8%83%E5%B1%82/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/Cloud_Computing/%E5%9B%9B%E5%B1%82%E8%BF%98%E6%98%AF%E4%B8%83%E5%B1%82/</guid> </item> <item> <title>redis</title> <description>&lt;p&gt;Redis（Remote Dictionary Server）是一个开源的内存数据存储系统，常用作缓存、消息代理和数据存储。它支持多种数据结构，如字符串、哈希、列表、集合、有序集合、位图、HyperLogLog等。&lt;/p&gt;&lt;h3&gt;Redis的特点：&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;内存存储&lt;/strong&gt;：Redis将数据存储在内存中，提供非常快的...&lt;/li&gt;&lt;/ol&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/database/redis/redis/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Fri, 29 Nov 2024 10:01:31 +0800</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/database/redis/redis/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/database/redis/redis/</guid> </item> <item> <title>redis_info详解</title> <description>&lt;p&gt;Redis info信息含义&lt;/p&gt;&lt;p&gt;```bash127.0.0.1:6379&amp;gt; info&lt;/p&gt;&lt;h1&gt;Server&lt;/h1&gt;&lt;p&gt;redis_version:6.2.16 # Redis 的版本号redis_git_sha1:00000000 # Redis 的 Git 提交 IDredis_git_dirty:0 # 是否...&lt;/p&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/database/redis/redis_info/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Fri, 29 Nov 2024 10:01:31 +0800</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/database/redis/redis_info/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/database/redis/redis_info/</guid> </item> <item> <title>redis_info_stats详解</title> <description>&lt;p&gt;&lt;code&gt;INFO stats&lt;/code&gt; 输出内容，保留原格式并在每行后面添加注释说明：&lt;/p&gt;&lt;p&gt;```bash127.0.0.1:6379&amp;gt; INFO stats&lt;/p&gt;&lt;h1&gt;Stats&lt;/h1&gt;&lt;p&gt;total_connections_received:13 # Redis 接收到的客户端连接总数total_commands_processed...&lt;/p&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/database/redis/redis_info_stats/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Fri, 29 Nov 2024 10:01:31 +0800</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/database/redis/redis_info_stats/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/database/redis/redis_info_stats/</guid> </item> <item> <title>redis作为缓存的优化方案</title> <description>&lt;p&gt;Redis 作为缓存系统，常见的优化设置包括以下几个方面，旨在提高性能、减少延迟、提升稳定性和扩展性。下面是一些常见的优化配置：&lt;/p&gt;&lt;h3&gt;1. &lt;strong&gt;内存管理优化&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;[ ] &lt;strong&gt;maxmemory&lt;/strong&gt; 设置 Redis 实例的最大内存限制，当内存达到限制时，Redis 会根据 `maxmemory-...&lt;/li&gt;&lt;/ul&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/database/redis/redis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Fri, 29 Nov 2024 10:01:31 +0800</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/database/redis/redis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/database/redis/redis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</guid> </item> <item> <title>redis快速部署</title> <description>&lt;p&gt;Redis单机部署比较简单，以下是一个基本的部署步骤：&lt;/p&gt;&lt;h3&gt;1. &lt;strong&gt;安装Redis&lt;/strong&gt;&lt;/h3&gt;&lt;h4&gt;在Linux上安装Redis（以Ubuntu为例）：&lt;/h4&gt;&lt;p&gt;&lt;code&gt;bashsudo apt updatesudo apt install redis-server&lt;/code&gt;&lt;/p&gt;&lt;h4&gt;在CentOS上安装R...&lt;/h4&gt;</description><link>https://yinzhipeng123.github.io/markdown_log/database/redis/redis%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2/?utm_source=documentation&amp;utm_medium=RSS&amp;utm_campaign=feed-syndication</link> <pubDate>Fri, 29 Nov 2024 10:01:31 +0800</pubDate><source url="https://yinzhipeng123.github.io/markdown_log/feed_rss_updated.xml">MarkDown_Log</source><comments>https://yinzhipeng123.github.io/markdown_log/database/redis/redis%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2/#__comments</comments><guid isPermaLink="true">https://yinzhipeng123.github.io/markdown_log/database/redis/redis%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2/</guid> </item> </channel></rss>